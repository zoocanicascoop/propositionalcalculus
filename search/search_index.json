{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"propositionalcalculus","text":"<p>Este repositorio contiene una implementaci\u00f3n en python de la l\u00f3gica proposicional, que permite manipular f\u00f3rmulas, aplicar reglas de inferencia y comprobar la correcci\u00f3n de demostraciones.</p>"},{"location":"#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"#paquete-de-python","title":"Paquete de python","text":"<ul> <li>Usando poetry</li> <li>Usando wheel</li> </ul> <pre><code>poetry install                     # Instalar dependencias\npoetry shell                       # Activar el entorno virtual de python\n</code></pre>"},{"location":"logica/","title":"L\u00f3gica proposicional","text":""},{"location":"logica/#formulas","title":"F\u00f3rmulas","text":"<p>Las f\u00f3rmulas se definen de forma recursiva y por casos:</p> <ul> <li> <p>Una variable es una f\u00f3rmula. Las variables se identifican y distinguen con   letras may\u00fasculas (formalmente habr\u00eda que considerar lenguaje y un conjunto de   s\u00edmbolos). Se llaman variables porque se les pueden asignar valores de verdad   distintos: a las variables se les pueden asignar valores booleanos    (verdadero o falso).</p> </li> <li> <p>Una constante es una f\u00f3rmula. Se identifica tambi\u00e9n con una letra may\u00fascula.   En nuestro caso estamos considerando las constantes <code>T</code>, con valor sem\u00e1ntico   verdadero, y <code>F</code>, con valor sem\u00e1ntico falso. Para que no haya confilctos   con las variables, se a\u00f1ade la restrucci\u00f3n de que los s\u00edmbolos <code>T</code> y <code>F</code> no se   puedan usar para nombrar variables.</p> </li> <li> <p>Una negaci\u00f3n es una f\u00f3rmula que se define recursivamente a partir de otra   f\u00f3rmula dada (operador unario). La negaci\u00f3n invierte el valor sem\u00e1ntico de la   f\u00f3rmula a la que se aplica: si la f\u00f3rmula toma el valor verdadero, la    negaci\u00f3n toma el valor falso; si el valor es falso, toma el valor   verdadero.</p> </li> </ul>"},{"location":"logica/reconocimiento-de-patrones/","title":"Reconocimiento de patrones","text":""},{"location":"logica/tablas-de-verdad/","title":"Tablas de verdad","text":"<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>"},{"location":"referencia/formulas/","title":"Formula","text":"<p>A class for representing propositional formulas of classical logic.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>class Formula:\n    \"\"\"\n    A class for representing propositional formulas of classical logic.\n    \"\"\"\n\n    def __str__(self):\n        return repr(self)\n\n    @property\n    def str_polish(self) -&gt; str:\n        raise NotImplementedError()\n\n    @staticmethod\n    def parse_polish(string: str, stack: list[Formula] = []) -&gt; Formula | None:\n        \"\"\"Parses a formula expressed in the reversed polish notation.\"\"\"\n        string = string.replace(\" \", \"\")\n        if len(string) == 0:\n            return stack.pop()\n        match string[-1]:\n            case Neg.symbol:\n                assert len(stack) &gt;= 1\n                f = stack.pop()\n                stack.append(Neg(f))\n                return Formula.parse_polish(string[0:-1], stack)\n            case And.symbol:\n                assert len(stack) &gt;= 2\n                A = stack.pop()\n                B = stack.pop()\n                stack.append(And(A, B))\n            case Or.symbol:\n                assert len(stack) &gt;= 2\n                A = stack.pop()\n                B = stack.pop()\n                stack.append(Or(A, B))\n            case Imp.symbol:\n                assert len(stack) &gt;= 2\n                A = stack.pop()\n                B = stack.pop()\n                stack.append(Imp(A, B))\n            case \"T\":\n                stack.append(Const.TRUE)\n            case \"F\":\n                stack.append(Const.FALSE)\n            case _ as c:\n                assert c in Var.var_names\n                stack.append(Var(c))\n        return Formula.parse_polish(string[0:-1], stack)\n\n    @cached_property\n    def graph(self):\n        \"\"\"Graphviz code for visually representing the formula tree.\"\"\"\n        return \"graph {\\n  \" + \"\\n  \".join(self._graph_rec()) + \"\\n}\"\n\n    def render_graph(self, path=\"./graph.gv\"):\n        \"\"\"Utility for rendering the formula tree with graphviz.\"\"\"\n        import graphviz\n        from graphviz.backend.rendering import pathlib\n\n        filepath = pathlib.Path(path)\n        filepath.write_text(self.graph, encoding=\"utf8\")\n        graphviz.render(\"dot\", \"pdf\", filepath).replace(\"\\\\\", \"/\")\n\n    def _graph_rec(self, prefix=\"\") -&gt; list[str]:\n        def name(f: Formula) -&gt; str:\n            match f:\n                case Var() | Const():\n                    return str(f)\n                case UnaryOperator() | BinaryOperator():\n                    return f.__class__.__name__\n                case _:\n                    raise ValueError(f\"UNREACHABLE\")\n\n        match self:\n            case Var() | Const():\n                return [f\"{prefix}{self} [label={self}]\"]\n            case UnaryOperator(f):\n                prefix = f\"{prefix}{name(self)}\"\n                future_name = f\"{prefix}{name(f)}\"\n                return [\n                    f\"{prefix} -- {future_name}\",\n                    f\"{prefix} [label={self.symbol}]\",\n                ] + self.f._graph_rec(prefix)\n            case BinaryOperator(A, B):\n                prefix = f\"{prefix}{name(self)}\"\n                future_name_A = f\"{prefix}L{name(A)}\"\n                future_name_B = f\"{prefix}R{name(B)}\"\n                return (\n                    [\n                        f\"{prefix} [label={self.symbol}]\",\n                        f\"{prefix} -- {future_name_A}\",\n                        f\"{prefix} -- {future_name_B}\",\n                    ]\n                    + A._graph_rec(prefix + \"L\")\n                    + B._graph_rec(prefix + \"R\")\n                )\n            case _:\n                raise ValueError(f\"UNREACHABLE\")\n\n    def __eq__(self, other):\n        return str(self) == str(other)\n\n    def __invert__(self):\n        return Neg(self)\n\n    def __and__(self, other):\n        return And(self, other)\n\n    def __or__(self, other):\n        return Or(self, other)\n\n    def __rshift__(self, other):\n        return Imp(self, other)\n\n    def __hash__(self):\n        return hash(repr(self))\n\n    def __len__(self) -&gt; int:\n        match self:\n            case Var() | Const():\n                return 1\n            case UnaryOperator():\n                return 1 + len(self.f)\n            case BinaryOperator():\n                return 1 + len(self.left) + len(self.right)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @staticmethod\n    def random(n_vars: int, max_depth: int, include_consts: bool = False) -&gt; Formula:\n        \"\"\"\n        Generates a random formula, represented in the reverse polish notation.\n\n        :n_vars: number of variables from wich to choice when generating the random formula\n        :max_depth: maximum depth of the formula tree\n        :include_consts: wether to include constants in the formula generation\n        \"\"\"\n        f = Formula.parse_polish(\n            Formula.random_polish(n_vars, max_depth, include_consts)\n        )\n        assert isinstance(f, Formula)\n        return f\n\n    @staticmethod\n    def random_polish(n_vars: int, max_depth: int, include_consts: bool = False) -&gt; str:\n        \"\"\"\n        Generates a random formula, represented in the reverse polish notation.\n\n        :n_vars: number of variables from wich to choice when generating the random string\n        :max_depth: maximum depth of the formula tree\n        :include_consts: wether to include constants in the formula generation\n        \"\"\"\n        assert max_depth &gt;= 1\n        if max_depth == 1:\n            if include_consts and randint(0, 1) == 0:\n                return choice([\"T\", \"F\"])\n            return str(choice(Var.generate(n_vars)))\n        else:\n            f_ = lambda: Formula.random_polish(\n                n_vars, randint(1, max_depth - 1), include_consts\n            )\n            match randint(0, 3):\n                case 0:\n                    return f\"\u00ac {f_()}\"\n                case 1:\n                    return f\"\u2227 {f_()} {f_()}\"\n                case 2:\n                    return f\"\u2228 {f_()} {f_()}\"\n                case 3:\n                    return f\"\u2192 {f_()} {f_()}\"\n                case _:\n                    raise ValueError(\"UNREACHABLE\")\n\n    # Old implementation of random\n    # @staticmethod\n    # def random(n_vars: int, n_iters: int, include_consts: bool = False) -&gt; Formula:\n    #     \"\"\"Random formula generator.\"\"\"\n    #     formulas: set[Const | Var | Neg | And | Or | Imp] = set(Var.generate(n_vars))\n    #     if include_consts:\n    #         formulas = formulas.union({Const.FALSE, Const.TRUE})\n    #     current_formula = None\n    #     assert n_iters &gt; 0, \"El n\u00famero de iteraciones debe ser positivo\"\n    #     for _ in range(n_iters):\n    #         option = choice([\"unary\", \"binary\"])\n    #         if option == \"unary\":\n    #             Op = choice(unary_operators)\n    #             f = choice(list(formulas))\n    #             current_formula = Op(f)\n    #         elif option == \"binary\":\n    #             Op = choice(binary_operators)\n    #             f1, f2 = sample(list(formulas), 2)\n    #             current_formula = Op(f1, f2)\n    #         assert isinstance(current_formula, Formula)\n    #         formulas.add(current_formula)\n    #     assert isinstance(current_formula, Formula)\n    #     return current_formula\n\n    @cached_property\n    def vars(self) -&gt; set[\"Var\"]:\n        \"\"\"Set of variables present in the formula.\"\"\"\n        match self:\n            case Var():\n                return {self}\n            case Const():\n                return set()\n            case UnaryOperator():\n                return self.f.vars\n            case BinaryOperator():\n                return self.left.vars.union(self.right.vars)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def consts(self) -&gt; set[\"Const\"]:\n        \"\"\"Set of constants present in the formula.\"\"\"\n        match self:\n            case Var():\n                return set()\n            case Const():\n                return {self}\n            case UnaryOperator():\n                return self.f.consts\n            case BinaryOperator():\n                return self.left.consts.union(self.right.consts)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    def subs(self, binding: Binding) -&gt; Formula:\n        \"\"\"\n        Substitutes variables of the formula with formulas.\n\n        :binding: the dictionary that maps variables to formulas.\n        \"\"\"\n        match self:\n            case Var():\n                return binding[self] if self in binding else self\n            case Const():\n                return self\n            case UnaryOperator(A):\n                return self.__class__(A.subs(binding))\n            case BinaryOperator(A, B):\n                return self.__class__(A.subs(binding), B.subs(binding))\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    def traverse(\n        self, order_type: OrderType = OrderType.BREADTH_FIRST\n    ) -&gt; Iterator[Formula]:\n        \"\"\"Traverses the formula tree in the given OrderType.\"\"\"\n        match order_type:\n            case OrderType.PREORDER:\n                return self.traverse_preorder()\n            case OrderType.BREADTH_FIRST:\n                return self.traverse_breadth()\n\n    def traverse_preorder(self) -&gt; Iterator[Formula]:\n        \"\"\"Preorder tree traversal.\"\"\"\n        match self:\n            case Var() | Const():\n                yield self\n            case UnaryOperator(A):\n                yield self\n                yield from A.traverse_preorder()\n            case BinaryOperator(A, B):\n                yield self\n                yield from A.traverse_preorder()\n                yield from B.traverse_preorder()\n\n    def traverse_breadth(self) -&gt; Iterator[Formula]:\n        \"\"\"Breadth first tree traversal.\"\"\"\n        queue = [self]\n        while len(queue) &gt; 0:\n            v = queue.pop()\n            yield v\n            match v:\n                case Var() | Const():\n                    pass\n                case UnaryOperator(A):\n                    queue.insert(0, A)\n                case BinaryOperator(A, B):\n                    queue.insert(0, A)\n                    queue.insert(0, B)\n\n    @staticmethod\n    def from_traversal_breadth_first(traversal: Iterable[Formula]) -&gt; Formula:\n        traversal = list(traversal)\n        assert len(traversal) &gt; 0\n        queue = []\n        v: Formula = Const.TRUE  # for type checking\n        while len(traversal) &gt; 0:\n            v = traversal.pop()\n            match v:\n                case Var() | Const():\n                    queue.append(v)\n                case UnaryOperator():\n                    f = queue.pop(0)\n                    queue.append(v.__class__(f))\n                case BinaryOperator():\n                    right = queue.pop(0)\n                    left = queue.pop(0)\n                    queue.append(v.__class__(left, right))\n        return queue.pop()\n\n    def replace_at_pos(\n        self, pos: int, f: Formula, order_type: OrderType = OrderType.BREADTH_FIRST\n    ) -&gt; Formula:\n        assert pos &lt; len(self)\n        match order_type:\n            case OrderType.PREORDER:\n                return self.replace_at_pos_preorder(pos, f)\n            case OrderType.BREADTH_FIRST:\n                return self.replace_at_pos_breadth(pos, f)\n\n    def replace_at_pos_preorder(\n        self, pos: int, f: Formula, current_pos: int = 0\n    ) -&gt; Formula:\n        if current_pos == pos:\n            return f\n        match self:\n            case Var() | Const():\n                return self\n            case UnaryOperator(A):\n                return self.__class__(\n                    A.replace_at_pos_preorder(pos, f, current_pos + 1)\n                )\n            case BinaryOperator(A, B):\n                left = A.replace_at_pos_preorder(pos, f, current_pos + 1)\n                right = B.replace_at_pos_preorder(pos, f, current_pos + 1 + len(left))\n                return self.__class__(left, right)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    def replace_at_pos_breadth(self, pos: int, f: Formula) -&gt; Formula:\n        queue = [self]\n        traversal = []\n        i = 0\n        while len(queue) &gt; 0:\n            v = queue.pop()\n            if pos == i:\n                queue.append(f)\n            else:\n                traversal.append(v)\n                match v:\n                    case Var() | Const():\n                        pass\n                    case UnaryOperator(A):\n                        queue.insert(0, A)\n                    case BinaryOperator(A, B):\n                        queue.insert(0, A)\n                        queue.insert(0, B)\n            i += 1\n        return Formula.from_traversal_breadth_first(traversal)\n\n    @cached_property\n    def simp_double_neg(self) -&gt; Formula:\n        \"\"\"Equivalent function where all double negations are simplified.\"\"\"\n        match self:\n            case Var() | Const():\n                return self\n            case Neg(Neg(f)):\n                return f.simp_double_neg\n            case UnaryOperator(f):\n                return self.__class__(f.simp_double_neg)\n            case BinaryOperator(left, right):\n                return self.__class__(left.simp_double_neg, right.simp_double_neg)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def subs_imp(self) -&gt; Formula:\n        \"\"\"\n        Equivalent funciton where all implications are substituted using the\n        A \u2192 B iff \u00acA \u2228 B equivalence.\n        \"\"\"\n        match self:\n            case Var() | Const():\n                return self\n            case UnaryOperator(f):\n                return self.__class__(f.subs_imp)\n            case Imp(left, right):\n                return Or(Neg(left.subs_imp), right.subs_imp)\n            case BinaryOperator(left, right):\n                return self.__class__(left.subs_imp, right.subs_imp)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def push_neg(self) -&gt; Formula:\n        \"\"\"\n        Equivalent function where all the negations are pushed down into the\n        formula tree, using De Morgan formulas. Double negations are also\n        eliminated.\n        \"\"\"\n        match self:\n            case Var() | Const():\n                return self\n            case Neg(Var()) | Neg(Const()):\n                return Neg(self.f)\n            case Neg(Neg(f)):\n                return f.push_neg\n            case Neg(And(left, right)):\n                return Or(Neg(left).push_neg, Neg(right).push_neg)\n            case Neg(Or(left, right)):\n                return And(Neg(left).push_neg, Neg(right).push_neg)\n            case Neg(Imp(left, right)):\n                return And(left.push_neg, Neg(right).push_neg)\n            case BinaryOperator(left, right):\n                return self.__class__(left.push_neg, right.push_neg)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def distribute_or(self) -&gt; Formula:\n        \"\"\"\n        Equivalent function where the distributive property of the disjuntion is\n        applied.\n        \"\"\"\n        f1, f2 = self, self._distribute_or_step\n        while f2 != f1:\n            f1 = f2\n            f2 = f1._distribute_or_step\n        return f1\n\n    @cached_property\n    def _distribute_or_step(self) -&gt; Formula:\n        \"\"\"\n        Equivalent function where the distributive property of the disjunction\n        is applied once in all subtrees of the formula.\n        \"\"\"\n        match self:\n            case Var() | Const():\n                return self\n            case UnaryOperator(f):\n                return self.__class__(f._distribute_or_step)\n            case Or(And(A, B), C):\n                return And(\n                    Or(A._distribute_or_step, C._distribute_or_step),\n                    Or(B._distribute_or_step, C._distribute_or_step),\n                )\n            case Or(A, And(B, C)):\n                return And(\n                    Or(A._distribute_or_step, B._distribute_or_step),\n                    Or(A._distribute_or_step, C._distribute_or_step),\n                )\n            case BinaryOperator(left, right):\n                return self.__class__(\n                    left._distribute_or_step, right._distribute_or_step\n                )\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def simp_const(self) -&gt; Formula:\n        \"\"\"\n        Equivalent formula where all the redundant constants and negations of\n        constants are simplified.\n        \"\"\"\n        f1, f2 = self, self._simp_const_step\n        while f2 != f1:\n            f1 = f2\n            f2 = f1._simp_const_step\n        return f1\n\n    @cached_property\n    def _simp_const_step(self) -&gt; Formula:\n        match self:\n            case Var() | Const():\n                return self\n            case Neg(Const.TRUE):\n                return Const.FALSE\n            case Neg(Const.FALSE):\n                return Const.TRUE\n            case Neg(A):\n                return Neg(A._simp_const_step)\n            case And(Const.TRUE, B):\n                return B._simp_const_step\n            case And(A, Const.TRUE):\n                return A._simp_const_step\n            case And(Const.FALSE, _):\n                return Const.FALSE\n            case And(_, Const.FALSE):\n                return Const.FALSE\n            case Or(_, Const.TRUE):\n                return Const.TRUE\n            case Or(Const.TRUE, _):\n                return Const.TRUE\n            case Or(A, Const.FALSE):\n                return A._simp_const_step\n            case Or(Const.FALSE, A):\n                return A._simp_const_step\n            case Imp(Const.TRUE, A):\n                return A._simp_const_step\n            case Imp(_, Const.TRUE):\n                return Const.TRUE\n            case Imp(Const.FALSE, _):\n                return Const.TRUE\n            case Imp(A, Const.FALSE):\n                return Neg(A._simp_const_step)\n            case BinaryOperator(A, B):\n                return self.__class__(A._simp_const_step, B._simp_const_step)\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n\n    @cached_property\n    def CNF(self) -&gt; Formula:\n        \"\"\"\n        Conjunctive Normal Form.\n\n        This normal form is calculated by appliying sequentially the following equivalences:\n        - All implications are removed using subs_imp,\n        - all negations are pushed down the formula tree with push_neg,\n        - the distributive property of disjuntion is applied with distribute_or,\n        - redundant constants are deleted using simp_const.\n        \"\"\"\n        return self.subs_imp.push_neg.distribute_or.simp_const\n\n    @cached_property\n    def CNF_structured(self) -&gt; list[set[Neg | Var | Const]]:\n        \"\"\"\n        A structured version of the CNF.\n\n        This function returns a list of sets of simple formulas (negations of\n        variables, variables or constants).\n        \"\"\"\n        self = self.CNF\n        result: list[set[Neg | Var | Const]] = list()\n        current_set: set[Neg | Var | Const] = set()\n        i = 0\n        f_str = str(self)\n        while i &lt; len(f_str):\n            if f_str[i] == \"\u00ac\":\n                i += 1\n                if f_str[i] == \"T\":\n                    current_set.add(Const.FALSE)\n                elif f_str[i] == \"F\":\n                    current_set.add(Const.TRUE)\n                else:\n                    current_set.add(Neg(Var(f_str[i])))\n            elif f_str[i] == \"\u2227\":\n                result.append(current_set)\n                current_set = set()\n            elif f_str[i] == \"\u2228\" or f_str[i] == \"(\" or f_str[i] == \")\":\n                pass\n            else:\n                if f_str[i] == \"T\":\n                    current_set.add(Const.TRUE)\n                elif f_str[i] == \"F\":\n                    current_set.add(Const.FALSE)\n                else:\n                    current_set.add(Var(f_str[i]))\n            i += 1\n        result.append(current_set)\n        return result\n\n    @staticmethod\n    def print_CNF_structured(cnf: list[set[Formula]]) -&gt; str:\n        return \"\u2227\".join(\n            [f\"({'\u2228'.join([ str(e) for e in list(disj)])})\" for disj in cnf]\n        )\n\n    @cached_property\n    def is_tauto(self) -&gt; bool:\n        \"\"\"Determines if the formula is a tautology, using the formula CNF\"\"\"\n        for l in self.CNF_structured:\n            affirmative, negative = set(), set()\n            for f in l:\n                match f:\n                    case Const.TRUE:\n                        return True\n                    case Const.FALSE:\n                        return False\n                    case Neg(f):\n                        negative.add(f)\n                    case Var():\n                        affirmative.add(f)\n                    case _:\n                        raise ValueError(\"UNREACHABLE\")\n            if len(affirmative.intersection(negative)) == 0:\n                return False\n        return True\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.CNF","title":"<code>CNF: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Conjunctive Normal Form.</p> <p>This normal form is calculated by appliying sequentially the following equivalences: - All implications are removed using subs_imp, - all negations are pushed down the formula tree with push_neg, - the distributive property of disjuntion is applied with distribute_or, - redundant constants are deleted using simp_const.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.CNF_structured","title":"<code>CNF_structured: list[set[Neg | Var | Const]]</code>  <code>cached</code> <code>property</code>","text":"<p>A structured version of the CNF.</p> <p>This function returns a list of sets of simple formulas (negations of variables, variables or constants).</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.consts","title":"<code>consts: set['Const']</code>  <code>cached</code> <code>property</code>","text":"<p>Set of constants present in the formula.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.distribute_or","title":"<code>distribute_or: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Equivalent function where the distributive property of the disjuntion is applied.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.graph","title":"<code>graph</code>  <code>cached</code> <code>property</code>","text":"<p>Graphviz code for visually representing the formula tree.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.is_tauto","title":"<code>is_tauto: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Determines if the formula is a tautology, using the formula CNF</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.push_neg","title":"<code>push_neg: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Equivalent function where all the negations are pushed down into the formula tree, using De Morgan formulas. Double negations are also eliminated.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.simp_const","title":"<code>simp_const: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Equivalent formula where all the redundant constants and negations of constants are simplified.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.simp_double_neg","title":"<code>simp_double_neg: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Equivalent function where all double negations are simplified.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.subs_imp","title":"<code>subs_imp: Formula</code>  <code>cached</code> <code>property</code>","text":"<p>Equivalent funciton where all implications are substituted using the A \u2192 B iff \u00acA \u2228 B equivalence.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.vars","title":"<code>vars: set['Var']</code>  <code>cached</code> <code>property</code>","text":"<p>Set of variables present in the formula.</p>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.parse_polish","title":"<code>parse_polish(string, stack=[])</code>  <code>staticmethod</code>","text":"<p>Parses a formula expressed in the reversed polish notation.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>@staticmethod\ndef parse_polish(string: str, stack: list[Formula] = []) -&gt; Formula | None:\n    \"\"\"Parses a formula expressed in the reversed polish notation.\"\"\"\n    string = string.replace(\" \", \"\")\n    if len(string) == 0:\n        return stack.pop()\n    match string[-1]:\n        case Neg.symbol:\n            assert len(stack) &gt;= 1\n            f = stack.pop()\n            stack.append(Neg(f))\n            return Formula.parse_polish(string[0:-1], stack)\n        case And.symbol:\n            assert len(stack) &gt;= 2\n            A = stack.pop()\n            B = stack.pop()\n            stack.append(And(A, B))\n        case Or.symbol:\n            assert len(stack) &gt;= 2\n            A = stack.pop()\n            B = stack.pop()\n            stack.append(Or(A, B))\n        case Imp.symbol:\n            assert len(stack) &gt;= 2\n            A = stack.pop()\n            B = stack.pop()\n            stack.append(Imp(A, B))\n        case \"T\":\n            stack.append(Const.TRUE)\n        case \"F\":\n            stack.append(Const.FALSE)\n        case _ as c:\n            assert c in Var.var_names\n            stack.append(Var(c))\n    return Formula.parse_polish(string[0:-1], stack)\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.random","title":"<code>random(n_vars, max_depth, include_consts=False)</code>  <code>staticmethod</code>","text":"<p>Generates a random formula, represented in the reverse polish notation.</p> <p>:n_vars: number of variables from wich to choice when generating the random formula :max_depth: maximum depth of the formula tree :include_consts: wether to include constants in the formula generation</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>@staticmethod\ndef random(n_vars: int, max_depth: int, include_consts: bool = False) -&gt; Formula:\n    \"\"\"\n    Generates a random formula, represented in the reverse polish notation.\n\n    :n_vars: number of variables from wich to choice when generating the random formula\n    :max_depth: maximum depth of the formula tree\n    :include_consts: wether to include constants in the formula generation\n    \"\"\"\n    f = Formula.parse_polish(\n        Formula.random_polish(n_vars, max_depth, include_consts)\n    )\n    assert isinstance(f, Formula)\n    return f\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.random_polish","title":"<code>random_polish(n_vars, max_depth, include_consts=False)</code>  <code>staticmethod</code>","text":"<p>Generates a random formula, represented in the reverse polish notation.</p> <p>:n_vars: number of variables from wich to choice when generating the random string :max_depth: maximum depth of the formula tree :include_consts: wether to include constants in the formula generation</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>@staticmethod\ndef random_polish(n_vars: int, max_depth: int, include_consts: bool = False) -&gt; str:\n    \"\"\"\n    Generates a random formula, represented in the reverse polish notation.\n\n    :n_vars: number of variables from wich to choice when generating the random string\n    :max_depth: maximum depth of the formula tree\n    :include_consts: wether to include constants in the formula generation\n    \"\"\"\n    assert max_depth &gt;= 1\n    if max_depth == 1:\n        if include_consts and randint(0, 1) == 0:\n            return choice([\"T\", \"F\"])\n        return str(choice(Var.generate(n_vars)))\n    else:\n        f_ = lambda: Formula.random_polish(\n            n_vars, randint(1, max_depth - 1), include_consts\n        )\n        match randint(0, 3):\n            case 0:\n                return f\"\u00ac {f_()}\"\n            case 1:\n                return f\"\u2227 {f_()} {f_()}\"\n            case 2:\n                return f\"\u2228 {f_()} {f_()}\"\n            case 3:\n                return f\"\u2192 {f_()} {f_()}\"\n            case _:\n                raise ValueError(\"UNREACHABLE\")\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.render_graph","title":"<code>render_graph(path='./graph.gv')</code>","text":"<p>Utility for rendering the formula tree with graphviz.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>def render_graph(self, path=\"./graph.gv\"):\n    \"\"\"Utility for rendering the formula tree with graphviz.\"\"\"\n    import graphviz\n    from graphviz.backend.rendering import pathlib\n\n    filepath = pathlib.Path(path)\n    filepath.write_text(self.graph, encoding=\"utf8\")\n    graphviz.render(\"dot\", \"pdf\", filepath).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.subs","title":"<code>subs(binding)</code>","text":"<p>Substitutes variables of the formula with formulas.</p> <p>:binding: the dictionary that maps variables to formulas.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>def subs(self, binding: Binding) -&gt; Formula:\n    \"\"\"\n    Substitutes variables of the formula with formulas.\n\n    :binding: the dictionary that maps variables to formulas.\n    \"\"\"\n    match self:\n        case Var():\n            return binding[self] if self in binding else self\n        case Const():\n            return self\n        case UnaryOperator(A):\n            return self.__class__(A.subs(binding))\n        case BinaryOperator(A, B):\n            return self.__class__(A.subs(binding), B.subs(binding))\n        case _:\n            raise ValueError(\"UNREACHABLE\")\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.traverse","title":"<code>traverse(order_type=OrderType.BREADTH_FIRST)</code>","text":"<p>Traverses the formula tree in the given OrderType.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>def traverse(\n    self, order_type: OrderType = OrderType.BREADTH_FIRST\n) -&gt; Iterator[Formula]:\n    \"\"\"Traverses the formula tree in the given OrderType.\"\"\"\n    match order_type:\n        case OrderType.PREORDER:\n            return self.traverse_preorder()\n        case OrderType.BREADTH_FIRST:\n            return self.traverse_breadth()\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.traverse_breadth","title":"<code>traverse_breadth()</code>","text":"<p>Breadth first tree traversal.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>def traverse_breadth(self) -&gt; Iterator[Formula]:\n    \"\"\"Breadth first tree traversal.\"\"\"\n    queue = [self]\n    while len(queue) &gt; 0:\n        v = queue.pop()\n        yield v\n        match v:\n            case Var() | Const():\n                pass\n            case UnaryOperator(A):\n                queue.insert(0, A)\n            case BinaryOperator(A, B):\n                queue.insert(0, A)\n                queue.insert(0, B)\n</code></pre>"},{"location":"referencia/formulas/#propositionalcalculus.formula.Formula.traverse_preorder","title":"<code>traverse_preorder()</code>","text":"<p>Preorder tree traversal.</p> Source code in <code>src/propositionalcalculus/formula.py</code> <pre><code>def traverse_preorder(self) -&gt; Iterator[Formula]:\n    \"\"\"Preorder tree traversal.\"\"\"\n    match self:\n        case Var() | Const():\n            yield self\n        case UnaryOperator(A):\n            yield self\n            yield from A.traverse_preorder()\n        case BinaryOperator(A, B):\n            yield self\n            yield from A.traverse_preorder()\n            yield from B.traverse_preorder()\n</code></pre>"}]}